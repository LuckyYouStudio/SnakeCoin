<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ² è›‡å¸NFTå¢å¼ºæŠ½å¥– - LuckYoué’±åŒ…é›†æˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 3rem;
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2rem;
            color: #666;
        }

        .wallet-section {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            border: 2px solid #dee2e6;
        }

        .wallet-section h2 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.8rem;
        }

        .wallet-detection {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 25px;
        }

        .wallet-option {
            background: white;
            border-radius: 12px;
            padding: 20px;
            border: 2px solid #e9ecef;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .wallet-option:hover {
            border-color: #007bff;
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .wallet-option.detected {
            border-color: #28a745;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
        }

        .wallet-option.not-detected {
            border-color: #dc3545;
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
        }

        .wallet-option.connected {
            border-color: #17a2b8;
            background: linear-gradient(135deg, #d1ecf1 0%, #bee5eb 100%);
        }

        .wallet-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .wallet-icon {
            font-size: 2rem;
            margin-right: 15px;
        }

        .wallet-name {
            font-size: 1.3rem;
            font-weight: bold;
            color: #333;
        }

        .wallet-status {
            margin-bottom: 15px;
            font-size: 0.95rem;
        }

        .status-detected {
            color: #155724;
            font-weight: bold;
        }

        .status-not-detected {
            color: #721c24;
            font-weight: bold;
        }

        .status-connected {
            color: #0c5460;
            font-weight: bold;
        }

        .wallet-btn {
            width: 100%;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .wallet-btn.connect {
            background: linear-gradient(45deg, #FF6B6B, #FF8E8E);
            color: white;
        }

        .wallet-btn.connect:hover:not(:disabled) {
            background: linear-gradient(45deg, #FF5252, #FF7676);
            transform: translateY(-1px);
        }

        .wallet-btn.disconnect {
            background: linear-gradient(45deg, #17a2b8, #20c997);
            color: white;
        }

        .wallet-btn.disconnect:hover:not(:disabled) {
            background: linear-gradient(45deg, #138496, #1e7e34);
            transform: translateY(-1px);
        }

        .wallet-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .wallet-info {
            background: white;
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #dee2e6;
            font-family: monospace;
            font-size: 0.9rem;
            display: none;
        }

        .lottery-section {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 2px solid #e9ecef;
        }

        .lottery-section h2 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
            font-size: 2rem;
        }

        .contract-info {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid #dee2e6;
        }

        .contract-info h3 {
            margin-bottom: 10px;
            color: #333;
        }

        .contract-info p {
            margin-bottom: 8px;
            font-family: monospace;
            font-size: 0.9rem;
            word-break: break-all;
        }

        .lottery-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .info-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 1px solid #dee2e6;
        }

        .info-card h3 {
            color: #333;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .info-card p {
            font-size: 1.5rem;
            font-weight: bold;
            color: #007bff;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .action-btn {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .action-btn:hover:not(:disabled) {
            background: #0056b3;
            transform: translateY(-2px);
        }

        .action-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        .action-btn.refresh {
            background: #17a2b8;
        }

        .action-btn.refresh:hover:not(:disabled) {
            background: #138496;
        }

        .action-btn.diagnose {
            background: #ffc107;
            color: #212529;
        }

        .action-btn.diagnose:hover:not(:disabled) {
            background: #e0a800;
        }

        .lottery-btn {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border: none;
            padding: 20px 40px;
            border-radius: 50px;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            max-width: 400px;
            margin: 0 auto;
            display: block;
        }

        .lottery-btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
        }

        .lottery-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
            font-weight: bold;
            border: 1px solid;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border-color: #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border-color: #f5c6cb;
        }

        .status.info {
            background: #d1ecf1;
            color: #0c5460;
            border-color: #bee5eb;
        }

        .status.warning {
            background: #fff3cd;
            color: #856404;
            border-color: #ffeaa7;
        }

        .tips {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            border: 1px solid #2196f3;
        }

        .tips h3 {
            color: #1565c0;
            margin-bottom: 10px;
        }

        .tips ul {
            color: #1565c0;
            margin-left: 20px;
        }

        .tips li {
            margin-bottom: 5px;
        }

        /* NFTå±•ç¤ºåŒºåŸŸæ ·å¼ */
        .nft-section {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            border: 2px solid #e9ecef;
        }

        .nft-section h2 {
            text-align: center;
            color: #333;
            margin-bottom: 25px;
            font-size: 2rem;
        }

        .tab-container {
            margin-bottom: 20px;
        }

        .tab-buttons {
            display: flex;
            border-bottom: 2px solid #e9ecef;
            margin-bottom: 20px;
        }

        .tab-button {
            background: none;
            border: none;
            padding: 12px 24px;
            font-size: 1.1rem;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            color: #6c757d;
            font-weight: 500;
        }

        .tab-button.active {
            color: #007bff;
            border-bottom-color: #007bff;
            background: rgba(0, 123, 255, 0.1);
        }

        .tab-button:hover:not(.active) {
            color: #495057;
            background: rgba(0, 0, 0, 0.05);
        }

        .tab-content {
            display: none;
            min-height: 200px;
        }

        .tab-content.active {
            display: block;
        }

        .nft-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .nft-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid #e9ecef;
        }

        .nft-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.15);
        }

        .nft-image {
            width: 100%;
            height: 200px;
            object-fit: cover;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #6c757d;
        }

        .nft-svg {
            width: 100%;
            height: 100%;
        }

        .nft-info {
            padding: 15px;
        }

        .nft-title {
            font-size: 1.1rem;
            font-weight: bold;
            color: #333;
            margin-bottom: 8px;
        }

        .nft-id {
            font-size: 0.9rem;
            color: #6c757d;
            font-family: monospace;
            margin-bottom: 8px;
        }

        .nft-traits {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .nft-trait {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            color: #1565c0;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .loading-spinner {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #6c757d;
        }

        .empty-state h3 {
            color: #495057;
            margin-bottom: 10px;
        }

        .empty-state p {
            margin-bottom: 20px;
        }

        .refresh-nft-btn {
            background: #17a2b8;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .refresh-nft-btn:hover:not(:disabled) {
            background: #138496;
            transform: translateY(-1px);
        }

        .refresh-nft-btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .wallet-detection {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .action-btn {
                width: 100%;
                max-width: 300px;
            }
            
            .nft-grid {
                grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
                gap: 15px;
            }
            
            .tab-buttons {
                flex-direction: column;
            }
            
            .tab-button {
                width: 100%;
                text-align: center;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ² è›‡å¸NFTå¢å¼ºæŠ½å¥–</h1>
            <p>è¿æ¥ LuckYou é’±åŒ…ï¼Œæ”¯ä»˜0.0001 ETHå‚ä¸çœŸå®æŠ½å¥–ï¼</p>
        </div>

        <div class="wallet-section">
            <h2>ğŸ”— æ™ºèƒ½é’±åŒ…æ£€æµ‹ä¸è¿æ¥</h2>
            
            <div class="wallet-detection">
                <div id="luckyouOption" class="wallet-option not-detected">
                    <div class="wallet-header">
                        <span class="wallet-icon">ğŸ€</span>
                        <span class="wallet-name">LuckYou Wallet</span>
                    </div>
                    <div id="luckyouStatus" class="wallet-status status-not-detected">
                        ğŸ” æ£€æµ‹ä¸­...
                    </div>
                    <button id="luckyouBtn" class="wallet-btn connect" onclick="connectLuckYou()" disabled>
                        è¿æ¥ LuckYou é’±åŒ…
                    </button>
                </div>

                <div id="metamaskOption" class="wallet-option not-detected">
                    <div class="wallet-header">
                        <span class="wallet-icon">ğŸ¦Š</span>
                        <span class="wallet-name">MetaMask</span>
                    </div>
                    <div id="metamaskStatus" class="wallet-status status-not-detected">
                        ğŸ” æ£€æµ‹ä¸­...
                    </div>
                    <button id="metamaskBtn" class="wallet-btn connect" onclick="connectMetaMask()" disabled>
                        è¿æ¥ MetaMask
                    </button>
                </div>
            </div>

            <div id="walletInfo" class="wallet-info">
                <!-- é’±åŒ…ä¿¡æ¯å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
            </div>
        </div>

        <div class="lottery-section">
            <h2>ğŸ¯ æŠ½å¥–ä¿¡æ¯</h2>
            
            <div class="contract-info">
                <h3>ğŸ“‹ åˆçº¦ä¿¡æ¯</h3>
                <p><strong>åˆçº¦åœ°å€:</strong> <span id="contractAddress">æœªè¿æ¥</span></p>
                <p><strong>ç½‘ç»œ:</strong> <span id="networkInfo">æœªè¿æ¥</span></p>
                <p><strong>çŠ¶æ€:</strong> <span id="contractStatus">ç­‰å¾…è¿æ¥</span></p>
            </div>

            <div class="lottery-info">
                <div class="info-card">
                    <h3>ğŸ’° æŠ½å¥–ä»·æ ¼</h3>
                    <p id="lotteryPrice">0.0001 ETH</p>
                </div>
                <div class="info-card">
                    <h3>ğŸ± æ± å­å¤§å°</h3>
                    <p id="poolSize">-</p>
                </div>
                <div class="info-card">
                    <h3>ğŸ”¢ å·²é“¸é€ </h3>
                    <p id="totalMinted">-</p>
                </div>
                <div class="info-card">
                    <h3>ğŸ“¦ å‰©ä½™æ•°é‡</h3>
                    <p id="remainingSupply">-</p>
                </div>
            </div>
            
            <div class="action-buttons">
                <button id="refreshInfoBtn" class="action-btn refresh" onclick="refreshContractInfo()">
                    ğŸ”„ åˆ·æ–°ä¿¡æ¯
                </button>
                <button id="diagnoseBtn" class="action-btn diagnose" onclick="diagnoseNetwork()">
                    ğŸ” ç½‘ç»œè¯Šæ–­
                </button>
                <button id="resetBtn" class="action-btn" onclick="resetConnection()">
                    ğŸ”„ é‡ç½®è¿æ¥
                </button>
            </div>

            <button id="lotteryBtn" class="lottery-btn" onclick="playLottery()" disabled>
                è¯·å…ˆè¿æ¥é’±åŒ…
            </button>

            <div id="statusDiv"></div>
        </div>

        <div class="nft-section">
            <h2>ğŸ–¼ï¸ æˆ‘çš„NFTæ”¶è—</h2>
            
            <div class="tab-container">
                <div class="tab-buttons">
                    <button class="tab-button active" onclick="switchTab('lottery-results')">
                        ğŸ² æˆ‘çš„æŠ½å¥–ç»“æœ
                    </button>
                    <button class="tab-button" onclick="switchTab('owned-nfts')">
                        ğŸ’ æˆ‘æ‹¥æœ‰çš„NFT
                    </button>
                </div>
                
                <div id="lottery-results" class="tab-content active">
                    <div class="empty-state">
                        <h3>ğŸ¯ æŠ½å¥–ç»“æœ</h3>
                        <p>è¿™é‡Œä¼šæ˜¾ç¤ºæ‚¨æœ€è¿‘æŠ½å¥–è·å¾—çš„NFT</p>
                        <button class="refresh-nft-btn" onclick="loadLotteryResults()" disabled>
                            ğŸ”„ åˆ·æ–°æŠ½å¥–ç»“æœ
                        </button>
                        <button class="refresh-nft-btn" onclick="debugNFTLoading()" disabled style="margin-left: 10px; background: #ffc107; color: #212529;">
                            ğŸ› è°ƒè¯•NFTåŠ è½½
                        </button>
                    </div>
                    <div id="lottery-nfts" class="nft-grid"></div>
                </div>
                
                <div id="owned-nfts" class="tab-content">
                    <div class="empty-state">
                        <h3>ğŸ’¼ æˆ‘çš„NFTæ”¶è—</h3>
                        <p>è¿™é‡Œä¼šæ˜¾ç¤ºæ‚¨æ‹¥æœ‰çš„æ‰€æœ‰è›‡å¸NFT</p>
                        <button class="refresh-nft-btn" onclick="loadOwnedNFTs()" disabled>
                            ğŸ”„ åˆ·æ–°NFTæ”¶è—
                        </button>
                        <button class="refresh-nft-btn" onclick="debugNFTLoading()" disabled style="margin-left: 10px; background: #ffc107; color: #212529;">
                            ğŸ› è°ƒè¯•NFTåŠ è½½
                        </button>
                    </div>
                    <div id="owned-nfts-grid" class="nft-grid"></div>
                </div>
            </div>
        </div>

        <div class="tips">
            <h3>ğŸ’¡ ä½¿ç”¨æç¤º</h3>
            <ul>
                <li>é¦–æ¬¡ä½¿ç”¨è¯·ç¡®ä¿å·²å®‰è£… LuckYou é’±åŒ…æµè§ˆå™¨æ‰©å±•</li>
                <li>ç¡®ä¿é’±åŒ…è¿æ¥åˆ°æ­£ç¡®çš„ç½‘ç»œ (Hardhat Local Network)</li>
                <li>æ¯æ¬¡æŠ½å¥–éœ€è¦æ”¯ä»˜ 0.0001 ETH çš„è´¹ç”¨</li>
                <li>æŠ½å¥–ç»“æœä¸ºéšæœºç”Ÿæˆçš„è›‡å¸NFTï¼Œå›¾æ¡ˆç‹¬ä¸€æ— äºŒ</li>
                <li>å¦‚é‡è¿æ¥é—®é¢˜ï¼Œå¯ç‚¹å‡»"ç½‘ç»œè¯Šæ–­"æˆ–"é‡ç½®è¿æ¥"</li>
            </ul>
        </div>
    </div>

    <script>
        // åˆçº¦é…ç½®
        const CONTRACT_ADDRESS = "0xCf7Ed3AccA5a467e9e704C703E8D87F634fB0Fc9";
        
        // æ­£ç¡®çš„ABIæ–¹æ³•ç­¾å
        const ABI_SIGNATURES = {
            lotteryPrice: '0xdbea52d8',
            getPoolSize: '0x23845e4b', 
            totalSupply: '0x18160ddd',
            playLottery: '0xd4cd77a3',
            balanceOf: '0x70a08231',
            ownerOf: '0x6352211e',
            tokenURI: '0xc87b56dd',
            generateSnakeSVG: '0x774f15a2'
        };

        // å…¨å±€çŠ¶æ€
        let walletProvider;
        let userAccount;
        let userBalance; 
        let currentWalletName;
        let connectionRetryCount = 0;
        const MAX_RETRY_COUNT = 3;

        // é’±åŒ…æ£€æµ‹ç»“æœ
        let walletDetection = {
            luckyou: false,
            metamask: false
        };

        // NFTç›¸å…³çŠ¶æ€
        let userNFTs = [];
        let lotteryResults = [];
        let currentActiveTab = 'lottery-results';

        // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        window.addEventListener('load', function() {
            console.log('ğŸš€ å¢å¼ºç‰ˆæŠ½å¥–é¡µé¢åŠ è½½å®Œæˆ');
            setTimeout(() => {
                detectWallets();
            }, 500);
        });

        // æ£€æµ‹å¯ç”¨é’±åŒ…
        function detectWallets() {
            console.log('ğŸ” å¼€å§‹æ£€æµ‹é’±åŒ…...');
            
            // æ£€æµ‹ LuckYou é’±åŒ…
            detectLuckYouWallet();
            
            // æ£€æµ‹ MetaMask
            detectMetaMask();
            
            // å»¶è¿Ÿæ£€æµ‹ï¼Œç¡®ä¿æ‰©å±•å®Œå…¨åŠ è½½
            setTimeout(() => {
                detectLuckYouWallet();
                detectMetaMask();
            }, 1000);
        }

        // æ£€æµ‹ LuckYou é’±åŒ…
        function detectLuckYouWallet() {
            const option = document.getElementById('luckyouOption');
            const status = document.getElementById('luckyouStatus');
            const btn = document.getElementById('luckyouBtn');
            
            let detected = false;
            
            if (typeof window.luckYou !== 'undefined') {
                detected = true;
                console.log('âœ… æ£€æµ‹åˆ°ä¸»è¦ LuckYou é’±åŒ…å¯¹è±¡');
            } else if (window.luckyouWallet && window.luckyouWallet.isLuckYouWallet) {
                detected = true;
                console.log('âœ… æ£€æµ‹åˆ°æ›¿ä»£ LuckYou é’±åŒ…å¯¹è±¡');
            } else {
                console.log('âŒ æœªæ£€æµ‹åˆ° LuckYou é’±åŒ…');
            }
            
            walletDetection.luckyou = detected;
            
            if (detected) {
                option.className = 'wallet-option detected';
                status.className = 'wallet-status status-detected';
                status.textContent = 'âœ… å·²æ£€æµ‹åˆ°ï¼Œå¯ä»¥è¿æ¥';
                btn.disabled = false;
            } else {
                option.className = 'wallet-option not-detected';
                status.className = 'wallet-status status-not-detected';
                status.textContent = 'âŒ æœªå®‰è£…æˆ–æœªå¯ç”¨';
                btn.disabled = true;
                btn.textContent = 'è¯·å®‰è£… LuckYou é’±åŒ…';
            }
        }

        // æ£€æµ‹ MetaMask
        function detectMetaMask() {
            const option = document.getElementById('metamaskOption');
            const status = document.getElementById('metamaskStatus');
            const btn = document.getElementById('metamaskBtn');
            
            let detected = false;
            
            if (window.ethereum && window.ethereum.isMetaMask) {
                detected = true;
                console.log('âœ… æ£€æµ‹åˆ° MetaMask');
            } else {
                console.log('âŒ æœªæ£€æµ‹åˆ° MetaMask');
            }
            
            walletDetection.metamask = detected;
            
            if (detected) {
                option.className = 'wallet-option detected';
                status.className = 'wallet-status status-detected';
                status.textContent = 'âœ… å·²æ£€æµ‹åˆ°ï¼Œå¯ä»¥è¿æ¥';
                btn.disabled = false;
            } else {
                option.className = 'wallet-option not-detected';
                status.className = 'wallet-status status-not-detected';
                status.textContent = 'âŒ æœªå®‰è£…æˆ–æœªå¯ç”¨';
                btn.disabled = true;
                btn.textContent = 'è¯·å®‰è£… MetaMask';
            }
        }

        // è¿æ¥ LuckYou é’±åŒ…
        async function connectLuckYou() {
            const btn = document.getElementById('luckyouBtn');
            const option = document.getElementById('luckyouOption');
            const status = document.getElementById('luckyouStatus');
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner"></span> è¿æ¥ä¸­...';
                showStatus('ğŸ”„ æ­£åœ¨è¿æ¥ LuckYou é’±åŒ…...', 'info');
                
                let provider;
                
                if (typeof window.luckYou !== 'undefined') {
                    provider = window.luckYou;
                } else if (window.luckyouWallet && window.luckyouWallet.isLuckYouWallet) {
                    provider = window.luckyouWallet;
                } else {
                    throw new Error('æœªæ£€æµ‹åˆ° LuckYou é’±åŒ…ï¼Œè¯·å®‰è£…æ‰©å±•ï¼');
                }
                
                // è¯·æ±‚è´¦æˆ·è¿æ¥
                const accounts = await provider.request({
                    method: 'eth_requestAccounts'
                });
                
                if (!accounts || accounts.length === 0) {
                    throw new Error('ç”¨æˆ·æ‹’ç»è¿æ¥æˆ–æ²¡æœ‰å¯ç”¨è´¦æˆ·');
                }
                
                await setupWalletConnection(provider, 'LuckYou Wallet', accounts[0]);
                
                // æ›´æ–°UIçŠ¶æ€
                option.className = 'wallet-option connected';
                status.className = 'wallet-status status-connected';
                status.textContent = 'ğŸ”— å·²è¿æ¥';
                btn.className = 'wallet-btn disconnect';
                btn.textContent = 'æ–­å¼€è¿æ¥';
                btn.onclick = disconnectWallet;
                
                showStatus('âœ… LuckYou é’±åŒ…è¿æ¥æˆåŠŸï¼', 'success');
                connectionRetryCount = 0;
                
            } catch (error) {
                console.error('LuckYou è¿æ¥å¤±è´¥:', error);
                showStatus(`âŒ LuckYou è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                btn.disabled = false;
                btn.innerHTML = 'è¿æ¥ LuckYou é’±åŒ…';
                
                // è¿æ¥é‡è¯•é€»è¾‘
                if (connectionRetryCount < MAX_RETRY_COUNT) {
                    connectionRetryCount++;
                    showStatus(`ğŸ”„ å°†åœ¨3ç§’åé‡è¯•è¿æ¥ (${connectionRetryCount}/${MAX_RETRY_COUNT})`, 'warning');
                    setTimeout(() => {
                        connectLuckYou();
                    }, 3000);
                }
            }
        }

        // è¿æ¥ MetaMask
        async function connectMetaMask() {
            const btn = document.getElementById('metamaskBtn');
            const option = document.getElementById('metamaskOption');
            const status = document.getElementById('metamaskStatus');
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner"></span> è¿æ¥ä¸­...';
                showStatus('ğŸ”„ æ­£åœ¨è¿æ¥ MetaMask...', 'info');
                
                if (!window.ethereum || !window.ethereum.isMetaMask) {
                    throw new Error('æœªæ£€æµ‹åˆ° MetaMaskï¼Œè¯·å®‰è£…æ‰©å±•ï¼');
                }
                
                const accounts = await window.ethereum.request({
                    method: 'eth_requestAccounts'
                });
                
                if (!accounts || accounts.length === 0) {
                    throw new Error('ç”¨æˆ·æ‹’ç»è¿æ¥æˆ–æ²¡æœ‰å¯ç”¨è´¦æˆ·');
                }
                
                await setupWalletConnection(window.ethereum, 'MetaMask', accounts[0]);
                
                // æ›´æ–°UIçŠ¶æ€
                option.className = 'wallet-option connected';
                status.className = 'wallet-status status-connected';
                status.textContent = 'ğŸ”— å·²è¿æ¥';
                btn.className = 'wallet-btn disconnect';
                btn.textContent = 'æ–­å¼€è¿æ¥';
                btn.onclick = disconnectWallet;
                
                showStatus('âœ… MetaMask è¿æ¥æˆåŠŸï¼', 'success');
                connectionRetryCount = 0;
                
            } catch (error) {
                console.error('MetaMask è¿æ¥å¤±è´¥:', error);
                showStatus(`âŒ MetaMask è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                btn.disabled = false;
                btn.innerHTML = 'è¿æ¥ MetaMask';
            }
        }

        // è®¾ç½®é’±åŒ…è¿æ¥
        async function setupWalletConnection(provider, walletName, account) {
            walletProvider = provider;
            currentWalletName = walletName;
            userAccount = account;
            
            console.log(`${walletName} è´¦æˆ·åœ°å€:`, userAccount);
            
            // æ£€æŸ¥ç½‘ç»œ
            const chainId = await provider.request({ method: 'eth_chainId' });
            const networkName = getNetworkName(chainId);
            
            console.log(`${walletName} ç½‘ç»œ Chain ID:`, chainId);
            console.log(`${walletName} ç½‘ç»œåç§°:`, networkName);
            
            // ç½‘ç»œæ£€æŸ¥å’Œåˆ‡æ¢ - ä¿®å¤åçš„é’±åŒ…åº”è¯¥é»˜è®¤ä½¿ç”¨æ­£ç¡®ç½‘ç»œ
            if (chainId !== '0x539' && chainId !== '0x31337' && chainId !== '0x7a69') {
                showStatus('âš ï¸ å½“å‰ç½‘ç»œä¸åŒ¹é…ï¼Œå°è¯•åˆ‡æ¢åˆ°æœ¬åœ° Hardhat ç½‘ç»œ...', 'warning');
                
                try {
                    await provider.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: '0x7a69' }]
                    });
                    console.log('å·²åˆ‡æ¢åˆ° Hardhat ç½‘ç»œ');
                    // åˆ‡æ¢æˆåŠŸåï¼Œé‡æ–°è·å–é“¾IDä»¥ç¡®è®¤
                    const newChainId = await provider.request({ method: 'eth_chainId' });
                    console.log('åˆ‡æ¢åçš„ç½‘ç»œ Chain ID:', newChainId);
                } catch (switchError) {
                    console.warn('ç½‘ç»œåˆ‡æ¢å¤±è´¥:', switchError);
                    showStatus('âŒ ç½‘ç»œåˆ‡æ¢å¤±è´¥ï¼Œè¯·æ£€æŸ¥é’±åŒ…é…ç½®æˆ–æ‰‹åŠ¨åˆ‡æ¢', 'error');
                    throw switchError;
                }
            } else {
                console.log('âœ… ç½‘ç»œåŒ¹é…ï¼Œä½¿ç”¨å½“å‰ç½‘ç»œ');
            }
            
            // è·å–è´¦æˆ·ä½™é¢ - å¢å¼ºçš„é”™è¯¯å¤„ç†å’Œé‡è¯•æœºåˆ¶
            try {
                console.log(`æ­£åœ¨è·å– ${walletName} è´¦æˆ·ä½™é¢...`);
                const balanceResult = await provider.request({
                    method: 'eth_getBalance',
                    params: [userAccount, 'latest']
                });
                
                console.log(`${walletName} åŸå§‹ä½™é¢ç»“æœ:`, balanceResult, typeof balanceResult);
                userBalance = typeof balanceResult === 'string' ? balanceResult : '0x0';
                console.log(`${walletName} å¤„ç†åä½™é¢:`, userBalance);
                
                // éªŒè¯ä½™é¢æ ¼å¼
                if (!userBalance.startsWith('0x')) {
                    console.warn('ä½™é¢æ ¼å¼å¼‚å¸¸ï¼Œå°è¯•ä¿®æ­£:', userBalance);
                    userBalance = '0x0';
                }
                
            } catch (balanceError) {
                console.error('è·å–ä½™é¢å¤±è´¥:', balanceError);
                userBalance = '0x0';
                showStatus('âš ï¸ ä½™é¢è·å–å¤±è´¥ï¼Œä½†è¿æ¥æˆåŠŸ', 'warning');
            }
            
            // æ›´æ–°UIå’Œå¯ç”¨åŠŸèƒ½
            updateWalletInfo(userAccount, userBalance, networkName, walletName);
            await updateLotteryInfo();
            enableLottery();
            enableNFTFeatures();
            
            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            setupWalletEventListeners(provider);
        }

        // è®¾ç½®é’±åŒ…äº‹ä»¶ç›‘å¬å™¨
        function setupWalletEventListeners(provider) {
            if (!provider.on) return;
            
            // è´¦æˆ·å˜æ›´ç›‘å¬
            provider.on('accountsChanged', (accounts) => {
                console.log('è´¦æˆ·å˜æ›´:', accounts);
                if (accounts.length === 0) {
                    disconnectWallet();
                } else {
                    userAccount = accounts[0];
                    location.reload(); // ç®€å•é‡æ–°åŠ è½½é¡µé¢
                }
            });
            
            // ç½‘ç»œå˜æ›´ç›‘å¬
            provider.on('chainChanged', (chainId) => {
                console.log('ç½‘ç»œå˜æ›´:', chainId);
                location.reload(); // ç®€å•é‡æ–°åŠ è½½é¡µé¢
            });
        }

        // æ–­å¼€é’±åŒ…è¿æ¥
        function disconnectWallet() {
            // é‡ç½®å…¨å±€çŠ¶æ€
            walletProvider = null;
            userAccount = null;
            userBalance = null;
            currentWalletName = null;
            connectionRetryCount = 0;
            
            // é‡ç½®UI
            document.getElementById('walletInfo').style.display = 'none';
            document.getElementById('lotteryBtn').disabled = true;
            document.getElementById('lotteryBtn').innerHTML = 'è¯·å…ˆè¿æ¥é’±åŒ…';
            
            // é‡ç½®åˆçº¦ä¿¡æ¯
            document.getElementById('contractAddress').textContent = 'æœªè¿æ¥';
            document.getElementById('networkInfo').textContent = 'æœªè¿æ¥';
            document.getElementById('contractStatus').textContent = 'ç­‰å¾…è¿æ¥';
            
            // é‡ç½®é’±åŒ…é€‰é¡¹çŠ¶æ€
            resetWalletOptions();
            
            showStatus('ğŸ”Œ é’±åŒ…å·²æ–­å¼€è¿æ¥', 'info');
            
            // é‡æ–°æ£€æµ‹é’±åŒ…
            setTimeout(() => {
                detectWallets();
            }, 1000);
        }

        // é‡ç½®é’±åŒ…é€‰é¡¹çŠ¶æ€
        function resetWalletOptions() {
            const walletOptions = ['luckyou', 'metamask'];
            
            walletOptions.forEach(wallet => {
                const option = document.getElementById(`${wallet}Option`);
                const status = document.getElementById(`${wallet}Status`);
                const btn = document.getElementById(`${wallet}Btn`);
                
                if (walletDetection[wallet]) {
                    option.className = 'wallet-option detected';
                    status.className = 'wallet-status status-detected';
                    status.textContent = 'âœ… å·²æ£€æµ‹åˆ°ï¼Œå¯ä»¥è¿æ¥';
                    btn.className = 'wallet-btn connect';
                    btn.disabled = false;
                    
                    if (wallet === 'luckyou') {
                        btn.textContent = 'è¿æ¥ LuckYou é’±åŒ…';
                        btn.onclick = connectLuckYou;
                    } else if (wallet === 'metamask') {
                        btn.textContent = 'è¿æ¥ MetaMask';
                        btn.onclick = connectMetaMask;
                    }
                }
            });
        }

        // é‡ç½®è¿æ¥
        function resetConnection() {
            showStatus('ğŸ”„ æ­£åœ¨é‡ç½®è¿æ¥...', 'info');
            disconnectWallet();
            
            setTimeout(() => {
                detectWallets();
                showStatus('âœ… è¿æ¥å·²é‡ç½®ï¼Œè¯·é‡æ–°é€‰æ‹©é’±åŒ…', 'success');
            }, 1500);
        }

        // æ›´æ–°é’±åŒ…ä¿¡æ¯æ˜¾ç¤º
        function updateWalletInfo(account, balance, network, walletName) {
            const walletInfo = document.getElementById('walletInfo');
            const contractAddress = document.getElementById('contractAddress');
            const networkInfo = document.getElementById('networkInfo');
            const contractStatus = document.getElementById('contractStatus');
            
            walletInfo.style.display = 'block';
            
            // å®‰å…¨è½¬æ¢ä½™é¢
            let balanceDisplay = '0 ETH';
            try {
                if (balance && typeof balance === 'string' && balance !== '0x0') {
                    const balanceWei = BigInt(balance);
                    const balanceEth = Number(balanceWei) / Math.pow(10, 18);
                    balanceDisplay = `${balanceEth.toFixed(6)} ETH`;
                }
            } catch (error) {
                console.error('ä½™é¢è½¬æ¢å¤±è´¥:', error);
                balanceDisplay = '0 ETH';
            }
            
            walletInfo.innerHTML = `
                <h3>ğŸ’¼ é’±åŒ…ä¿¡æ¯</h3>
                <p><strong>é’±åŒ…ç±»å‹:</strong> ${walletName}</p>
                <p><strong>è´¦æˆ·åœ°å€:</strong> ${account}</p>
                <p><strong>è´¦æˆ·ä½™é¢:</strong> ${balanceDisplay}</p>
                <p><strong>ç½‘ç»œ:</strong> ${network}</p>
                <p><strong>è¿æ¥çŠ¶æ€:</strong> âœ… å·²è¿æ¥</p>
            `;
            
            contractAddress.textContent = CONTRACT_ADDRESS;
            networkInfo.textContent = network;
            contractStatus.textContent = 'âœ… å·²è¿æ¥';
        }

        // è·å–ç½‘ç»œåç§°
        function getNetworkName(chainId) {
            const networks = {
                '0x1': 'Ethereum Mainnet',
                '0x3': 'Ropsten Testnet',
                '0x4': 'Rinkeby Testnet', 
                '0x5': 'Goerli Testnet',
                '0x2a': 'Kovan Testnet',
                '0x7a69': 'Hardhat Local Network',
                '0x539': 'Hardhat Local Network',
                '0x31337': 'Hardhat Local Network'
            };
            return networks[chainId] || `Chain ID: ${chainId}`;
        }

        // å¯ç”¨æŠ½å¥–åŠŸèƒ½
        function enableLottery() {
            const lotteryBtn = document.getElementById('lotteryBtn');
            lotteryBtn.disabled = false;
            lotteryBtn.innerHTML = 'ğŸ² å¼€å§‹æŠ½å¥– (0.0001 ETH)';
        }

        // åŸå§‹åˆçº¦è°ƒç”¨ - å¢å¼ºç‰ˆï¼Œé…åˆä¿®å¤åçš„RPC
        async function rawContractCall(methodSignature, decodeType = 'uint256') {
            if (!walletProvider) {
                throw new Error('é’±åŒ…æœªè¿æ¥');
            }

            try {
                console.log(`å‘èµ·åˆçº¦è°ƒç”¨: ${methodSignature} -> ${CONTRACT_ADDRESS}`);
                
                // æ·»åŠ è¶…æ—¶å¤„ç†
                const timeoutPromise = new Promise((_, reject) => {
                    setTimeout(() => reject(new Error('åˆçº¦è°ƒç”¨è¶…æ—¶')), 10000);
                });
                
                const callPromise = walletProvider.request({
                    method: 'eth_call',
                    params: [{
                        to: CONTRACT_ADDRESS,
                        data: methodSignature
                    }, 'latest']
                });
                
                const result = await Promise.race([callPromise, timeoutPromise]);

                console.log(`åˆçº¦è°ƒç”¨æˆåŠŸ ${methodSignature}:`, result, typeof result);

                // å¢å¼ºçš„ç»“æœéªŒè¯å’Œå¤„ç†
                if (result && typeof result === 'string' && result.startsWith('0x')) {
                    if (decodeType === 'uint256') {
                        try {
                            const bigIntValue = BigInt(result);
                            const stringValue = bigIntValue.toString();
                            console.log(`è§£ç  uint256: ${result} -> ${stringValue}`);
                            return stringValue;
                        } catch (parseError) {
                            console.error(`è§£ç å¤±è´¥ ${methodSignature}:`, parseError);
                            return '0';
                        }
                    } else if (decodeType === 'address') {
                        // å¤„ç†åœ°å€ç±»å‹è¿”å›å€¼
                        // æ ¼å¼ï¼š0x00000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c8
                        // éœ€è¦æå–æœ€å20å­—èŠ‚ï¼ˆ40ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ï¼‰
                        if (result.length === 66) {
                            const address = '0x' + result.slice(26).toLowerCase(); // 2 + 24 = 26
                            console.log(`è§£ç  address: ${result} -> ${address}`);
                            return address;
                        } else if (result.length === 42) {
                            console.log(`åœ°å€å·²æ˜¯æ ‡å‡†æ ¼å¼: ${result}`);
                            return result.toLowerCase();
                        } else {
                            console.warn(`æ„å¤–çš„åœ°å€æ ¼å¼: ${result}`);
                            return result;
                        }
                    } else if (decodeType === 'string') {
                        // å¤„ç†å­—ç¬¦ä¸²ç±»å‹è¿”å›å€¼
                        console.log(`è§£ç  string: ${result.substring(0, 100)}...`);
                        return result; // è¿”å›åŸå§‹åå…­è¿›åˆ¶ï¼Œè®©è°ƒç”¨è€…å¤„ç†
                    }
                    return result;
                }
                
                console.warn(`å¼‚å¸¸çš„åˆçº¦è°ƒç”¨ç»“æœ ${methodSignature}:`, result);
                return '0';
                
            } catch (error) {
                console.error(`åˆçº¦è°ƒç”¨å¤±è´¥ ${methodSignature}:`, error);
                
                // å¦‚æœæ˜¯è¶…æ—¶é”™è¯¯ï¼Œæä¾›æ›´å‹å¥½çš„æç¤º
                if (error.message.includes('timeout')) {
                    console.warn('åˆçº¦è°ƒç”¨è¶…æ—¶ï¼Œå¯èƒ½æ˜¯ç½‘ç»œæˆ–èŠ‚ç‚¹é—®é¢˜');
                }
                
                return '0';
            }
        }

        // æ›´æ–°æŠ½å¥–ä¿¡æ¯
        async function updateLotteryInfo() {
            if (!walletProvider) {
                console.log('é’±åŒ…æœªè¿æ¥ï¼Œè·³è¿‡æ›´æ–°æŠ½å¥–ä¿¡æ¯');
                return;
            }
            
            try {
                console.log('ğŸ”„ è·å–å®æ—¶æŠ½å¥–ä¿¡æ¯...');
                showStatus('ğŸ”„ æ›´æ–°æŠ½å¥–ä¿¡æ¯ä¸­...', 'info');
                
                const [price, poolSize, totalMinted] = await Promise.all([
                    rawContractCall(ABI_SIGNATURES.lotteryPrice),
                    rawContractCall(ABI_SIGNATURES.getPoolSize),
                    rawContractCall(ABI_SIGNATURES.totalSupply)
                ]);
                
                console.log('è·å–åˆ°çš„æ•°æ®:', { price, poolSize, totalMinted });
                
                // è®¡ç®—å‰©ä½™æ•°é‡
                const maxSupply = 1000;
                const remaining = maxSupply - parseInt(totalMinted || 0);
                
                // æ›´æ–°UI
                try {
                    const priceInEth = price === '0' ? '0.0001' : (BigInt(price) / BigInt(Math.pow(10, 18))).toString();
                    document.getElementById('lotteryPrice').textContent = `${priceInEth} ETH`;
                    document.getElementById('poolSize').textContent = poolSize || '0';
                    document.getElementById('totalMinted').textContent = totalMinted || '0';
                    document.getElementById('remainingSupply').textContent = remaining.toString();
                    
                    console.log('âœ… æŠ½å¥–ä¿¡æ¯æ›´æ–°æˆåŠŸ');
                    showStatus('âœ… æŠ½å¥–ä¿¡æ¯å·²æ›´æ–°', 'success');
                    
                } catch (uiError) {
                    console.error('æ›´æ–°UIå¤±è´¥:', uiError);
                    showStatus('âš ï¸ ä¿¡æ¯æ›´æ–°éƒ¨åˆ†å¤±è´¥', 'warning');
                }
                
            } catch (error) {
                console.error('è·å–æŠ½å¥–ä¿¡æ¯å¤±è´¥:', error);
                showStatus('âš ï¸ æ— æ³•è·å–å®æ—¶æŠ½å¥–ä¿¡æ¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥', 'warning');
            }
        }

        // åˆ·æ–°åˆçº¦ä¿¡æ¯
        async function refreshContractInfo() {
            if (!walletProvider) {
                showStatus('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }
            
            const btn = document.getElementById('refreshInfoBtn');
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner"></span> åˆ·æ–°ä¸­...';
                
                await updateLotteryInfo();
                
            } catch (error) {
                console.error('åˆ·æ–°å¤±è´¥:', error);
                showStatus(`âŒ åˆ·æ–°å¤±è´¥: ${error.message}`, 'error');
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // ç½‘ç»œè¯Šæ–­ - å¢å¼ºç‰ˆ
        async function diagnoseNetwork() {
            if (!walletProvider) {
                showStatus('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }
            
            const btn = document.getElementById('diagnoseBtn');
            const originalText = btn.textContent;
            
            try {
                btn.disabled = true;
                btn.innerHTML = '<span class="spinner"></span> è¯Šæ–­ä¸­...';
                showStatus('ğŸ” æ­£åœ¨è¿›è¡Œå…¨é¢ç½‘ç»œè¯Šæ–­...', 'info');
                
                console.log('ğŸ” å¼€å§‹å¢å¼ºç½‘ç»œè¯Šæ–­...');
                
                // 1. æ£€æŸ¥ç½‘ç»œä¿¡æ¯
                const chainId = await walletProvider.request({ method: 'eth_chainId' });
                const networkName = getNetworkName(chainId);
                console.log('âœ… å½“å‰ç½‘ç»œ:', chainId, networkName);
                
                if (chainId !== '0x539' && chainId !== '0x31337' && chainId !== '0x7a69') {
                    showStatus('âŒ ç½‘ç»œä¸åŒ¹é…ï¼šåˆçº¦ä»…é€‚ç”¨äºæœ¬åœ° Hardhat ç½‘ç»œ', 'error');
                    return;
                }
                
                // 2. æ£€æŸ¥ RPC è¿æ¥
                try {
                    const latestBlock = await walletProvider.request({
                        method: 'eth_blockNumber',
                        params: []
                    });
                    console.log('âœ… RPCè¿æ¥æ­£å¸¸ï¼Œæœ€æ–°åŒºå—å·:', latestBlock);
                } catch (rpcError) {
                    console.error('âŒ RPCè¿æ¥å¤±è´¥:', rpcError);
                    showStatus('âŒ RPCè¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥HardhatèŠ‚ç‚¹', 'error');
                    return;
                }
                
                // 3. æ£€æŸ¥åˆçº¦ä»£ç 
                const code = await walletProvider.request({
                    method: 'eth_getCode',
                    params: [CONTRACT_ADDRESS, 'latest']
                });
                
                if (!code || code === '0x' || code === '0x0') {
                    showStatus('âŒ åˆçº¦æœªéƒ¨ç½²ï¼è¯·è¿è¡Œ: npm run deploy:local', 'error');
                    console.error('åˆçº¦åœ°å€æ— ä»£ç :', CONTRACT_ADDRESS);
                    return;
                }
                
                console.log('âœ… åˆçº¦å·²éƒ¨ç½²ï¼Œä»£ç é•¿åº¦:', code.length);
                
                // 4. æµ‹è¯•æ‰€æœ‰åˆçº¦æ–¹æ³•
                console.log('ğŸ§ª æµ‹è¯•åˆçº¦æ–¹æ³•è°ƒç”¨...');
                const [price, poolSize, totalMinted] = await Promise.all([
                    rawContractCall(ABI_SIGNATURES.lotteryPrice).catch(() => 'fail'),
                    rawContractCall(ABI_SIGNATURES.getPoolSize).catch(() => 'fail'),
                    rawContractCall(ABI_SIGNATURES.totalSupply).catch(() => 'fail')
                ]);
                
                if (price === 'fail' || poolSize === 'fail' || totalMinted === 'fail') {
                    showStatus('âš ï¸ éƒ¨åˆ†åˆçº¦æ–¹æ³•è°ƒç”¨å¤±è´¥ï¼Œåˆçº¦å¯èƒ½æœªåˆå§‹åŒ–', 'warning');
                    console.warn('åˆçº¦æ–¹æ³•æµ‹è¯•ç»“æœ:', { price, poolSize, totalMinted });
                } else {
                    console.log('âœ… æ‰€æœ‰åˆçº¦æ–¹æ³•è°ƒç”¨æˆåŠŸ:', { price, poolSize, totalMinted });
                }
                
                // 5. æ£€æŸ¥è´¦æˆ·ä½™é¢
                const balance = await walletProvider.request({
                    method: 'eth_getBalance',
                    params: [userAccount, 'latest']
                });
                
                const balanceEth = Number(BigInt(balance)) / Math.pow(10, 18);
                console.log('âœ… è´¦æˆ·ä½™é¢:', balanceEth.toFixed(4), 'ETH');
                
                // 6. æ£€æŸ¥æŠ½å¥–æ± çŠ¶æ€
                if (poolSize === '0') {
                    showStatus('âš ï¸ è¯Šæ–­å®Œæˆï¼Œä½†æŠ½å¥–æ± æœªåˆå§‹åŒ–ã€‚è¯·è¿è¡Œåˆå§‹åŒ–è„šæœ¬ã€‚', 'warning');
                } else {
                    showStatus('âœ… ç½‘ç»œè¯Šæ–­å®Œæˆï¼šæ‰€æœ‰ç³»ç»Ÿæ­£å¸¸è¿è¡Œï¼', 'success');
                }
                
            } catch (error) {
                console.error('ç½‘ç»œè¯Šæ–­å¤±è´¥:', error);
                if (error.message.includes('timeout')) {
                    showStatus('âŒ ç½‘ç»œè¯Šæ–­è¶…æ—¶ï¼šè¯·æ£€æŸ¥HardhatèŠ‚ç‚¹æ˜¯å¦è¿è¡Œ', 'error');
                } else {
                    showStatus(`âŒ ç½‘ç»œè¯Šæ–­å¤±è´¥: ${error.message}`, 'error');
                }
            } finally {
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        // æŠ½å¥–åŠŸèƒ½
        async function playLottery() {
            if (!walletProvider || !userAccount) {
                showStatus('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            const lotteryBtn = document.getElementById('lotteryBtn');
            const originalText = lotteryBtn.innerHTML;
            
            try {
                lotteryBtn.disabled = true;
                lotteryBtn.innerHTML = '<span class="spinner"></span> æŠ½å¥–ä¸­...';
                showStatus('ğŸ² æ­£åœ¨æäº¤æŠ½å¥–äº¤æ˜“...', 'info');
                
                // è·å–æŠ½å¥–ä»·æ ¼
                const priceStr = await rawContractCall(ABI_SIGNATURES.lotteryPrice);
                const price = priceStr === '0' ? '0x5AF3107A4000' : '0x' + BigInt(priceStr).toString(16); // é»˜è®¤ 0.0001 ETH
                
                console.log('æŠ½å¥–ä»·æ ¼:', price);
                
                // æ£€æŸ¥ä½™é¢
                const balanceStr = await walletProvider.request({
                    method: 'eth_getBalance',
                    params: [userAccount, 'latest']
                });
                
                const userBalanceBig = BigInt(balanceStr);
                const priceBig = BigInt(price);
                
                if (userBalanceBig < priceBig) {
                    throw new Error('ä½™é¢ä¸è¶³ï¼Œæ— æ³•æ”¯ä»˜æŠ½å¥–è´¹ç”¨');
                }
                
                // å‘é€æŠ½å¥–äº¤æ˜“
                const txHash = await walletProvider.request({
                    method: 'eth_sendTransaction',
                    params: [{
                        from: userAccount,
                        to: CONTRACT_ADDRESS,
                        value: price,
                        data: ABI_SIGNATURES.playLottery,
                        gas: '0x493e0' // 300000
                    }]
                });
                
                console.log('æŠ½å¥–äº¤æ˜“å“ˆå¸Œ:', txHash);
                showStatus(`ğŸ‰ æŠ½å¥–äº¤æ˜“å·²æäº¤ï¼äº¤æ˜“å“ˆå¸Œ: ${txHash}`, 'success');
                
                // ç­‰å¾…ä¸€ä¼šå„¿å†æ›´æ–°ä¿¡æ¯
                setTimeout(async () => {
                    await updateLotteryInfo();
                    
                    // å¦‚æœå½“å‰åœ¨NFTæ ‡ç­¾é¡µï¼Œè‡ªåŠ¨åˆ·æ–°NFTæ•°æ®
                    if (currentActiveTab === 'lottery-results') {
                        await loadLotteryResults();
                        showStatus('ğŸ‰ æŠ½å¥–æˆåŠŸï¼NFTå·²æ·»åŠ åˆ°æ‚¨çš„æ”¶è—ä¸­', 'success');
                    } else if (currentActiveTab === 'owned-nfts') {
                        await loadOwnedNFTs();
                        showStatus('ğŸ‰ æŠ½å¥–æˆåŠŸï¼æ‚¨çš„NFTæ”¶è—å·²æ›´æ–°', 'success');
                    } else {
                        showStatus('ğŸ”„ æŠ½å¥–ä¿¡æ¯å·²æ›´æ–°', 'info');
                    }
                }, 3000);
                
            } catch (error) {
                console.error('æŠ½å¥–å¤±è´¥:', error);
                
                let errorMessage = error.message;
                if (error.code === 4001) {
                    errorMessage = 'ç”¨æˆ·æ‹’ç»äº†äº¤æ˜“';
                } else if (error.code === -32603) {
                    errorMessage = 'äº¤æ˜“æ‰§è¡Œå¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œå’Œåˆçº¦çŠ¶æ€';
                }
                
                showStatus(`âŒ æŠ½å¥–å¤±è´¥: ${errorMessage}`, 'error');
            } finally {
                lotteryBtn.disabled = false;
                lotteryBtn.innerHTML = originalText;
            }
        }

        // æ˜¾ç¤ºçŠ¶æ€æ¶ˆæ¯
        function showStatus(message, type) {
            const statusDiv = document.getElementById('statusDiv');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            
            // è‡ªåŠ¨æ¸…é™¤æˆåŠŸå’Œä¿¡æ¯æ¶ˆæ¯
            if (type === 'success' || type === 'info') {
                setTimeout(() => {
                    statusDiv.innerHTML = '';
                }, 6000);
            }
        }

        // é”™è¯¯å¤„ç†å’Œé‡è¯•é€»è¾‘
        window.addEventListener('error', function(event) {
            console.error('é¡µé¢é”™è¯¯:', event.error);
            showStatus('âš ï¸ é¡µé¢å‘ç”Ÿé”™è¯¯ï¼Œè¯·åˆ·æ–°é‡è¯•', 'warning');
        });

        // æœªå¤„ç†çš„Promiseé”™è¯¯
        window.addEventListener('unhandledrejection', function(event) {
            console.error('æœªå¤„ç†çš„Promiseé”™è¯¯:', event.reason);
            event.preventDefault();
        });

        // ==================== NFTåŠŸèƒ½ ====================
        
        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchTab(tabId) {
            console.log('åˆ‡æ¢åˆ°æ ‡ç­¾é¡µ:', tabId);
            currentActiveTab = tabId;
            
            // ç§»é™¤æ‰€æœ‰æ´»åŠ¨çŠ¶æ€
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // æ¿€æ´»å½“å‰æ ‡ç­¾
            event.target.classList.add('active');
            document.getElementById(tabId).classList.add('active');
            
            // å¦‚æœå·²è¿æ¥é’±åŒ…ï¼Œè‡ªåŠ¨åŠ è½½å¯¹åº”æ•°æ®
            if (walletProvider && userAccount) {
                if (tabId === 'lottery-results') {
                    loadLotteryResults();
                } else if (tabId === 'owned-nfts') {
                    loadOwnedNFTs();
                }
            }
        }

        // å¯ç”¨NFTåŠŸèƒ½
        function enableNFTFeatures() {
            document.querySelectorAll('.refresh-nft-btn').forEach(btn => {
                btn.disabled = false;
            });
            
            // è‡ªåŠ¨åŠ è½½å½“å‰æ´»åŠ¨æ ‡ç­¾çš„æ•°æ®
            if (currentActiveTab === 'lottery-results') {
                loadLotteryResults();
            } else if (currentActiveTab === 'owned-nfts') {
                loadOwnedNFTs();
            }
        }

        // åŠ è½½æŠ½å¥–ç»“æœNFT
        async function loadLotteryResults() {
            if (!walletProvider || !userAccount) {
                showStatus('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            const container = document.getElementById('lottery-nfts');
            const emptyState = document.querySelector('#lottery-results .empty-state');
            const refreshBtn = document.querySelector('#lottery-results .refresh-nft-btn');
            
            try {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<span class="spinner"></span> åŠ è½½ä¸­...';
                emptyState.style.display = 'none';
                
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                container.innerHTML = '<div class="loading-spinner"><span class="spinner"></span></div>';
                
                console.log('ğŸ” æ­£åœ¨åŠ è½½æŠ½å¥–ç»“æœNFT...');
                
                // ä½¿ç”¨å®Œæ•´çš„NFTåŠ è½½å‡½æ•°
                const nfts = await loadUserNFTsComplete();
                
                if (nfts.length > 0) {
                    // åªæ˜¾ç¤ºæœ€æ–°çš„5ä¸ªNFTä½œä¸ºæŠ½å¥–ç»“æœ
                    const recentNFTs = nfts.slice(0, 5);
                    lotteryResults = recentNFTs;
                    // containerä¼šåœ¨loadUserNFTsCompleteä¸­è¢«æ›´æ–°ï¼Œè¿™é‡Œä¸éœ€è¦å†æ¬¡è°ƒç”¨displayNFTs
                    console.log(`âœ… æˆåŠŸåŠ è½½ ${recentNFTs.length} ä¸ªæœ€è¿‘æŠ½å¥–NFT`);
                } else {
                    container.innerHTML = '';
                    emptyState.style.display = 'block';
                    emptyState.querySelector('p').textContent = 'æ‚¨è¿˜æ²¡æœ‰é€šè¿‡æŠ½å¥–è·å¾—NFTï¼Œå¿«å»è¯•è¯•è¿æ°”å§ï¼';
                    lotteryResults = [];
                }
                
            } catch (error) {
                console.error('åŠ è½½æŠ½å¥–ç»“æœå¤±è´¥:', error);
                container.innerHTML = '';
                emptyState.style.display = 'block';
                emptyState.querySelector('p').textContent = 'åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                showStatus('âŒ åŠ è½½æŠ½å¥–ç»“æœå¤±è´¥', 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'ğŸ”„ åˆ·æ–°æŠ½å¥–ç»“æœ';
            }
        }

        // åŠ è½½æ‹¥æœ‰çš„æ‰€æœ‰NFT
        async function loadOwnedNFTs() {
            if (!walletProvider || !userAccount) {
                showStatus('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            const container = document.getElementById('owned-nfts-grid');
            const emptyState = document.querySelector('#owned-nfts .empty-state');
            const refreshBtn = document.querySelector('#owned-nfts .refresh-nft-btn');
            
            try {
                refreshBtn.disabled = true;
                refreshBtn.innerHTML = '<span class="spinner"></span> åŠ è½½ä¸­...';
                emptyState.style.display = 'none';
                
                // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
                container.innerHTML = '<div class="loading-spinner"><span class="spinner"></span></div>';
                
                console.log('ğŸ” æ­£åœ¨åŠ è½½æ‰€æœ‰æ‹¥æœ‰çš„NFT...');
                
                // ä½¿ç”¨å®Œæ•´çš„NFTåŠ è½½å‡½æ•°
                const nfts = await loadUserNFTsComplete();
                
                if (nfts.length > 0) {
                    userNFTs = nfts;
                    // æ¸…ç©ºcontainerï¼Œå› ä¸ºloadUserNFTsCompleteå·²ç»æ˜¾ç¤ºäº†NFT
                    // containerä¼šåœ¨loadUserNFTsCompleteä¸­è¢«æ›´æ–°
                    console.log(`âœ… æˆåŠŸåŠ è½½ ${nfts.length} ä¸ªNFTåˆ°æ”¶è—é¡µé¢`);
                } else {
                    container.innerHTML = '';
                    emptyState.style.display = 'block';
                    emptyState.querySelector('p').textContent = 'æ‚¨è¿˜æ²¡æœ‰æ‹¥æœ‰ä»»ä½•è›‡å¸NFTï¼Œå¿«å»æŠ½å¥–è·å–å§ï¼';
                }
                
            } catch (error) {
                console.error('åŠ è½½NFTæ”¶è—å¤±è´¥:', error);
                container.innerHTML = '';
                emptyState.style.display = 'block';
                emptyState.querySelector('p').textContent = 'åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥';
                showStatus('âŒ åŠ è½½NFTæ”¶è—å¤±è´¥', 'error');
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'ğŸ”„ åˆ·æ–°NFTæ”¶è—';
            }
        }

        // åŠ è½½å•ä¸ªNFTæ•°æ®
        async function loadNFTData(tokenId) {
            try {
                console.log(`ğŸ” åŠ è½½NFTæ•°æ®: Token ID ${tokenId}`);
                
                // å…ˆå°è¯•ä½¿ç”¨tokenURIè·å–å®Œæ•´å…ƒæ•°æ®
                let svgData = '';
                let traits = [];
                
                try {
                    const tokenURIResult = await rawContractCall(
                        ABI_SIGNATURES.tokenURI + 
                        tokenId.toString(16).padStart(64, '0'),
                        'string'
                    );
                    
                    console.log(`ğŸ“„ Token ${tokenId} tokenURIç»“æœ:`, tokenURIResult);
                    
                    if (tokenURIResult && tokenURIResult !== '0x') {
                        console.log(`ğŸ“ Token ${tokenId} åŸå§‹tokenURI:`, tokenURIResult.substring(0, 200) + '...');
                        const decodedURI = hexToString(tokenURIResult);
                        console.log(`ğŸ“ Token ${tokenId} è§£ç åçš„URI:`, decodedURI.substring(0, 200) + '...');
                        
                        if (decodedURI.startsWith('data:application/json;base64,')) {
                            // è§£æBase64ç¼–ç çš„JSON
                            const base64Data = decodedURI.replace('data:application/json;base64,', '');
                            const jsonData = JSON.parse(atob(base64Data));
                            console.log(`âœ… Token ${tokenId} å…ƒæ•°æ®:`, jsonData);
                            
                            // æå–SVGå›¾åƒ
                            if (jsonData.image && jsonData.image.startsWith('data:image/svg+xml;base64,')) {
                                const svgBase64 = jsonData.image.replace('data:image/svg+xml;base64,', '');
                                svgData = atob(svgBase64);
                                console.log(`ğŸ¨ Token ${tokenId} SVGé•¿åº¦:`, svgData.length);
                            }
                            
                            // æå–ç‰¹å¾
                            if (jsonData.attributes && Array.isArray(jsonData.attributes)) {
                                traits = jsonData.attributes.map(attr => ({
                                    name: attr.trait_type,
                                    value: attr.value
                                }));
                            }
                        }
                    }
                } catch (uriError) {
                    console.warn(`âš ï¸ tokenURIè§£æå¤±è´¥ Token ${tokenId}:`, uriError);
                }
                
                // å¦‚æœtokenURIå¤±è´¥ï¼Œå°è¯•ç›´æ¥è·å–SVG
                if (!svgData) {
                    console.log(`ğŸ”„ Token ${tokenId} å°è¯•ç›´æ¥è·å–SVG...`);
                    
                    try {
                        const svgResult = await rawContractCall(
                            ABI_SIGNATURES.generateSnakeSVG + 
                            tokenId.toString(16).padStart(64, '0'),
                            'string'
                        );
                        
                        if (svgResult && svgResult !== '0x') {
                            console.log(`ğŸ” Token ${tokenId} åŸå§‹SVGç»“æœ:`, svgResult.substring(0, 200) + '...');
                            svgData = hexToString(svgResult);
                            console.log(`ğŸ¨ Token ${tokenId} è§£æåSVGé•¿åº¦:`, svgData.length);
                            
                            // éªŒè¯SVGæ˜¯å¦æœ‰æ•ˆ
                            if (svgData.length > 10 && svgData.includes('<svg')) {
                                console.log(`âœ… Token ${tokenId} SVGæœ‰æ•ˆ`);
                            } else {
                                console.warn(`âš ï¸ Token ${tokenId} SVGæ— æ•ˆï¼Œä½¿ç”¨å›é€€SVG`);
                                svgData = '';
                            }
                        }
                    } catch (svgError) {
                        console.warn(`âš ï¸ generateSnakeSVGå¤±è´¥ Token ${tokenId}:`, svgError);
                    }
                }
                
                // å¦‚æœè¿˜æ˜¯æ²¡æœ‰SVGï¼Œä½¿ç”¨å›é€€SVG
                if (!svgData) {
                    console.warn(`ğŸ”§ Token ${tokenId} ä½¿ç”¨å›é€€SVG`);
                    svgData = generateFallbackSVG(tokenId);
                }
                
                // å¦‚æœæ²¡æœ‰traitsï¼Œä»tokenIdç”Ÿæˆ
                if (traits.length === 0) {
                    traits = extractTraitsFromTokenId(tokenId);
                }
                
                const nftData = {
                    tokenId: tokenId,
                    name: `SnakeCoin #${tokenId}`,
                    image: svgData,
                    traits: traits
                };
                
                console.log(`âœ… Token ${tokenId} æ•°æ®åŠ è½½å®Œæˆ`, nftData);
                return nftData;
                
            } catch (error) {
                console.error(`âŒ åŠ è½½NFTæ•°æ®å¤±è´¥ Token ${tokenId}:`, error);
                return {
                    tokenId: tokenId,
                    name: `SnakeCoin #${tokenId}`,
                    image: generateFallbackSVG(tokenId),
                    traits: [{ name: 'Status', value: 'Error Loading' }]
                };
            }
        }

        // åå…­è¿›åˆ¶å­—ç¬¦ä¸²è½¬æ™®é€šå­—ç¬¦ä¸² - æ”¹è¿›ç‰ˆ
        function hexToString(hex) {
            if (!hex || hex === '0x') return '';
            
            try {
                // ç§»é™¤0xå‰ç¼€
                hex = hex.replace('0x', '');
                console.log(`ğŸ” hexToStringè¾“å…¥: ${hex.substring(0, 100)}... (é•¿åº¦: ${hex.length})`);
                
                if (hex.length < 64) {
                    console.warn('hexæ•°æ®å¤ªçŸ­ï¼Œæ— æ³•è§£æ');
                    return '';
                }
                
                // å‰32å­—èŠ‚(64ä¸ªåå…­è¿›åˆ¶å­—ç¬¦)æ˜¯åç§»é‡ï¼ŒæŒ‡å‘æ•°æ®å¼€å§‹ä½ç½®
                const offsetHex = hex.substring(0, 64);
                const offset = parseInt(offsetHex, 16) * 2; // è½¬æ¢ä¸ºåå…­è¿›åˆ¶å­—ç¬¦ä½ç½®
                console.log(`ğŸ“ æ•°æ®åç§»é‡: ${offset}`);
                
                if (offset >= hex.length) {
                    console.warn('åç§»é‡è¶…å‡ºæ•°æ®èŒƒå›´');
                    return '';
                }
                
                // ä»åç§»ä½ç½®è¯»å–é•¿åº¦ï¼ˆæ¥ä¸‹æ¥32å­—èŠ‚ï¼‰
                const lengthHex = hex.substring(offset, offset + 64);
                const length = parseInt(lengthHex, 16);
                console.log(`ğŸ“ å­—ç¬¦ä¸²é•¿åº¦: ${length}`);
                
                if (length === 0) {
                    console.warn('å­—ç¬¦ä¸²é•¿åº¦ä¸º0');
                    return '';
                }
                
                // è¯»å–å®é™…å­—ç¬¦ä¸²æ•°æ®
                const dataStart = offset + 64;
                const dataEnd = dataStart + (length * 2);
                const dataHex = hex.substring(dataStart, dataEnd);
                console.log(`ğŸ“ å­—ç¬¦ä¸²æ•°æ®hex: ${dataHex.substring(0, 100)}... (é•¿åº¦: ${dataHex.length})`);
                
                if (dataHex.length === 0) {
                    console.warn('æ— å­—ç¬¦ä¸²æ•°æ®');
                    return '';
                }
                
                // è½¬æ¢ä¸ºå­—ç¬¦ä¸²
                let result = '';
                for (let i = 0; i < dataHex.length; i += 2) {
                    const charCode = parseInt(dataHex.substr(i, 2), 16);
                    if (charCode > 0) {
                        result += String.fromCharCode(charCode);
                    }
                }
                
                console.log(`âœ… è§£æç»“æœ: ${result.substring(0, 100)}... (é•¿åº¦: ${result.length})`);
                return result;
                
            } catch (error) {
                console.error('hexToStringè§£æå¤±è´¥:', error);
                return '';
            }
        }

        // ç”Ÿæˆå›é€€SVG - æ”¹è¿›ç‰ˆ
        function generateFallbackSVG(tokenId) {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#FFB347', '#87CEEB', '#98FB98', '#F0E68C'];
            const primaryColor = colors[tokenId % colors.length];
            const secondaryColor = colors[(tokenId + 1) % colors.length];
            
            console.log(`ğŸ¨ ç”ŸæˆToken ${tokenId} çš„å›é€€SVGï¼Œé¢œè‰²: ${primaryColor}, ${secondaryColor}`);
            
            return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" width="400" height="400">
                <defs>
                    <linearGradient id="grad${tokenId}" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:${primaryColor};stop-opacity:1" />
                        <stop offset="100%" style="stop-color:${secondaryColor};stop-opacity:1" />
                    </linearGradient>
                </defs>
                <rect width="100" height="100" fill="url(#grad${tokenId})" opacity="0.2"/>
                <path d="M10,50 Q30,30 50,50 T90,50" stroke="${primaryColor}" stroke-width="4" fill="none"/>
                <path d="M10,60 Q30,40 50,60 T90,60" stroke="${secondaryColor}" stroke-width="3" fill="none"/>
                <circle cx="15" cy="50" r="3" fill="${primaryColor}"/>
                <circle cx="85" cy="50" r="3" fill="${secondaryColor}"/>
                <text x="50" y="85" text-anchor="middle" font-family="Arial" font-size="10" fill="${primaryColor}" font-weight="bold">SnakeCoin #${tokenId}</text>
            </svg>`;
        }

        // ä»Token IDæå–ç‰¹å¾
        function extractTraitsFromTokenId(tokenId) {
            const tokenStr = tokenId.toString().padStart(7, '0');
            const colors = ['Red', 'Cyan', 'Blue', 'Green', 'Yellow', 'Purple', 'Orange', 'Sky Blue', 'Light Green', 'Khaki'];
            const patterns = ['Wave', 'Curve', 'Zigzag', 'Parabola', 'Double Wave', 'Double Curve', 'Sawtooth', 'Symmetric Wave', 'Complex Curve', 'Dense Wave'];
            
            return [
                { name: 'Token ID', value: `#${tokenId}` },
                { name: 'Primary Color', value: colors[parseInt(tokenStr[0]) % 10] },
                { name: 'Secondary Color', value: colors[parseInt(tokenStr[1]) % 10] },
                { name: 'Pattern', value: patterns[parseInt(tokenStr[2]) % 10] }
            ];
        }

        // æ˜¾ç¤ºNFTåˆ—è¡¨
        function displayNFTs(nfts, container) {
            container.innerHTML = '';
            
            if (nfts.length === 0) {
                container.innerHTML = '<div class="empty-state"><p>æš‚æ— NFTæ•°æ®</p></div>';
                return;
            }
            
            nfts.forEach(nft => {
                const nftCard = createNFTCard(nft);
                container.appendChild(nftCard);
            });
        }

        // åˆ›å»ºNFTå¡ç‰‡
        function createNFTCard(nft) {
            const card = document.createElement('div');
            card.className = 'nft-card';
            
            const imageHtml = nft.image.includes('<svg') 
                ? `<div class="nft-image">${nft.image}</div>`
                : `<div class="nft-image">åŠ è½½ä¸­...</div>`;
            
            const traitsHtml = nft.traits.map(trait => 
                `<span class="nft-trait">${trait.name}: ${trait.value}</span>`
            ).join('');
            
            card.innerHTML = `
                ${imageHtml}
                <div class="nft-info">
                    <div class="nft-title">${nft.name}</div>
                    <div class="nft-id">Token ID: ${nft.tokenId}</div>
                    <div class="nft-traits">${traitsHtml}</div>
                </div>
            `;
            
            return card;
        }

        // æ‰«æç”¨æˆ·æ‹¥æœ‰çš„NFTï¼ˆæ›¿ä»£tokenOfOwnerByIndexæ–¹æ³•ï¼‰
        async function scanUserNFTs(expectedCount) {
            const userNFTs = [];
            
            try {
                console.log('=== å¼€å§‹æ‰«æç”¨æˆ·NFT ===');
                console.log(`ğŸ” æœŸæœ›æ‰¾åˆ° ${expectedCount} ä¸ªNFT`);
                console.log(`ğŸ‘¤ ç”¨æˆ·åœ°å€: ${userAccount}`);
                
                // è·å–æ€»ä¾›åº”é‡
                const totalSupplyResult = await rawContractCall(ABI_SIGNATURES.totalSupply);
                const totalSupply = parseInt(totalSupplyResult || '0');
                
                console.log(`ğŸ“Š æ€»ä¾›åº”é‡: ${totalSupply}`);
                
                if (totalSupply === 0) {
                    console.log('âš ï¸ æ€»ä¾›åº”é‡ä¸º0ï¼Œæ²¡æœ‰NFTå¯æ‰«æ');
                    return userNFTs;
                }
                
                // æ›´æ–°æ‰«æçŠ¶æ€ï¼ˆå¦‚æœéœ€è¦ï¼‰
                updateScanningStatus(`ğŸ” æ­£åœ¨æŸ¥æ‰¾æ‚¨çš„NFT...`);
                
                // éå†æ‰€æœ‰å¯èƒ½çš„tokenIdï¼Œæ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰
                let userNFTCount = 0;
                const maxSupply = Math.min(totalSupply, 1000); // é™åˆ¶æ‰«æèŒƒå›´ï¼Œé¿å…è¶…æ—¶
                const userTokenIds = []; // å­˜å‚¨æ‰¾åˆ°çš„Token ID
                
                // åˆ†æ‰¹å¤„ç†ï¼Œé¿å…ä¸€æ¬¡æ€§å¤„ç†å¤ªå¤šè¯·æ±‚
                const batchSize = 20; // å‡å°æ‰¹æ¬¡å¤§å°ï¼Œé¿å…RPCè¶…æ—¶
                let processedCount = 0;
                
                // ä»æœ€æ–°çš„NFTå¼€å§‹æ‰«æï¼ˆå€’åºï¼‰ï¼Œè¿™æ ·æŠ½å¥–ç»“æœä¼šä¼˜å…ˆæ˜¾ç¤º
                for (let tokenId = totalSupply - 1; tokenId >= 0 && userNFTCount < expectedCount; tokenId--) {
                    try {
                        // æ£€æŸ¥è¯¥tokenIdçš„æ‹¥æœ‰è€…
                        const ownerResult = await rawContractCall(
                            ABI_SIGNATURES.ownerOf + 
                            tokenId.toString(16).padStart(64, '0'),
                            'address'
                        );
                        
                        if (processedCount < 10) { // åªè®°å½•å‰10ä¸ªçš„è¯¦ç»†ä¿¡æ¯
                            console.log(`Token ${tokenId} çš„æ‰€æœ‰è€…:`, ownerResult);
                        }
                        
                        if (ownerResult && ownerResult !== '0x' && ownerResult !== '0x0000000000000000000000000000000000000000') {
                            if (ownerResult === userAccount.toLowerCase()) {
                                console.log(`âœ… æ‰¾åˆ°ç”¨æˆ·æ‹¥æœ‰çš„NFT: Token ${tokenId}`);
                                userTokenIds.push(tokenId);
                                userNFTCount++;
                            } else if (processedCount < 10) {
                                console.log(`âŒ Token ${tokenId} ä¸å±äºå½“å‰ç”¨æˆ·`);
                            }
                        } else if (processedCount < 10) {
                            console.log(`âš ï¸ Token ${tokenId} æ— æœ‰æ•ˆæ‹¥æœ‰è€…`);
                        }
                        
                        processedCount++;
                        
                        // æ¯å¤„ç†ä¸€æ‰¹ï¼Œæ›´æ–°çŠ¶æ€
                        if (processedCount % batchSize === 0) {
                            updateScanningStatus(`ğŸ” å·²æ£€æŸ¥ ${processedCount}/${totalSupply} ä¸ªToken...`);
                            console.log(`å·²å¤„ç† ${processedCount}/${totalSupply} ä¸ªTokenï¼Œæ‰¾åˆ° ${userNFTCount} ä¸ªNFT`);
                            
                            // æ·»åŠ çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡äºé¢‘ç¹
                            await new Promise(resolve => setTimeout(resolve, 100));
                        }
                        
                    } catch (error) {
                        // tokenä¸å­˜åœ¨æˆ–å‡ºé”™ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
                        if (processedCount < 10) { // åªè®°å½•å‰10ä¸ªé”™è¯¯
                            console.log(`Token ${tokenId} ä¸å­˜åœ¨æˆ–å‡ºé”™:`, error.message);
                        }
                        processedCount++;
                        continue;
                    }
                }
                
                console.log('=== æ‰«æå®Œæˆ ===');
                console.log('ç”¨æˆ·æ‹¥æœ‰NFTæ•°é‡:', userNFTCount);
                console.log('æ‰¾åˆ°çš„NFT Token IDs:', userTokenIds);
                
                if (userNFTCount > 0) {
                    updateScanningStatus(`âœ… æ‰¾åˆ° ${userNFTCount} ä¸ªNFTï¼Œæ­£åœ¨åŠ è½½è¯¦ç»†ä¿¡æ¯...`);
                    
                    // æŒ‰å€’åºæ’åˆ—ï¼Œæœ€æ–°çš„æ’åœ¨å‰é¢
                    userTokenIds.sort((a, b) => b - a);
                    console.log('å€’åºæ’åˆ—åçš„NFT Token IDs:', userTokenIds);
                    
                    // åŠ è½½æ¯ä¸ªNFTçš„è¯¦ç»†æ•°æ®
                    for (const tokenId of userTokenIds) {
                        try {
                            updateScanningStatus(`ğŸ“¦ æ­£åœ¨åŠ è½½NFT ${tokenId}...`);
                            const nftData = await loadNFTData(tokenId);
                            if (nftData) {
                                userNFTs.push(nftData);
                                console.log(`ğŸ“¦ å·²æ·»åŠ NFT ${tokenId}ï¼Œå½“å‰æ€»æ•°: ${userNFTs.length}`);
                            }
                        } catch (nftError) {
                            console.error(`åŠ è½½NFT ${tokenId} æ•°æ®å¤±è´¥:`, nftError);
                            // ç»§ç»­åŠ è½½å…¶ä»–NFT
                        }
                    }
                    
                    updateScanningStatus(`âœ… å®Œæˆï¼æˆåŠŸåŠ è½½ ${userNFTs.length} ä¸ªNFT`);
                } else {
                    updateScanningStatus('ğŸ“­ æ‚¨è¿˜æ²¡æœ‰ä»»ä½•NFT');
                    console.log('ç”¨æˆ·æ²¡æœ‰æ‰¾åˆ°ä»»ä½•NFTï¼Œå¯èƒ½çš„åŸå› :');
                    console.log('1. ç”¨æˆ·ç¡®å®æ²¡æœ‰NFT');
                    console.log('2. ç½‘ç»œä¸åŒæ­¥');
                    console.log('3. åˆçº¦è°ƒç”¨æƒé™é—®é¢˜');
                    console.log('4. é’±åŒ…RPCèŠ‚ç‚¹é—®é¢˜');
                }
                
                console.log(`ğŸ‰ æœ€ç»ˆæ‰«æç»“æœï¼šæ‰¾åˆ° ${userNFTs.length} ä¸ªç”¨æˆ·NFT`);
                return userNFTs;
                
            } catch (error) {
                console.error('âŒ æ‰«æç”¨æˆ·NFTå¤±è´¥:', error);
                updateScanningStatus('âŒ æ‰«æå¤±è´¥ï¼Œè¯·é‡è¯•');
                return [];
            }
        }
        
        // æ›´æ–°æ‰«æçŠ¶æ€ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
        function updateScanningStatus(message) {
            // å°è¯•æ›´æ–°ä¸åŒä½ç½®çš„çŠ¶æ€æ˜¾ç¤º
            const statusElements = [
                document.querySelector('#lottery-results .empty-state p'),
                document.querySelector('#owned-nfts .empty-state p'),
                document.querySelector('.nft-status') // å¦‚æœæœ‰çŠ¶æ€æ 
            ];
            
            statusElements.forEach(element => {
                if (element) {
                    element.textContent = message;
                }
            });
            
            console.log(`[çŠ¶æ€æ›´æ–°] ${message}`);
        }

        // å®Œæ•´çš„ç”¨æˆ·NFTåŠ è½½å‡½æ•°ï¼ˆç±»ä¼¼lottery-realçš„å®ç°ï¼‰
        async function loadUserNFTsComplete() {
            if (!walletProvider || !userAccount) {
                showStatus('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }
            
            try {
                console.log('=== å¼€å§‹å®Œæ•´åŠ è½½ç”¨æˆ·NFT ===');
                console.log('ç”¨æˆ·åœ°å€:', userAccount);
                console.log('åˆçº¦åœ°å€:', CONTRACT_ADDRESS);
                
                // è·å–æ€»ä¾›åº”é‡
                const totalSupplyResult = await rawContractCall(ABI_SIGNATURES.totalSupply);
                const totalSupply = parseInt(totalSupplyResult || '0');
                console.log('æ€»ä¾›åº”é‡:', totalSupply.toString());
                
                if (totalSupply === 0) {
                    showStatus('ğŸ“­ ç›®å‰è¿˜æ²¡æœ‰ä»»ä½•NFT', 'info');
                    return [];
                }
                
                showStatus('ğŸ” æ­£åœ¨æŸ¥æ‰¾æ‚¨çš„NFT...', 'info');
                console.log('å¼€å§‹æŸ¥æ‰¾ç”¨æˆ·NFTï¼Œç”¨æˆ·åœ°å€:', userAccount);
                
                // éå†æ‰€æœ‰å¯èƒ½çš„tokenIdï¼Œæ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ‹¥æœ‰
                let userNFTCount = 0;
                const maxSupply = Math.min(totalSupply, 1000); // é™åˆ¶æ‰«æèŒƒå›´
                const userNFTs = []; // å­˜å‚¨æ‰¾åˆ°çš„NFTä¿¡æ¯
                
                // åˆ†æ‰¹å¤„ç†ï¼Œé¿å…ä¸€æ¬¡æ€§å¤„ç†å¤ªå¤šè¯·æ±‚
                const batchSize = 30;
                let processedCount = 0;
                
                for (let tokenId = 0; tokenId < maxSupply; tokenId++) {
                    try {
                        // æ£€æŸ¥tokenæ˜¯å¦å­˜åœ¨
                        const ownerResult = await rawContractCall(
                            ABI_SIGNATURES.ownerOf + 
                            tokenId.toString(16).padStart(64, '0'),
                            'address'
                        );
                        
                        if (processedCount < 10) { // åªè®°å½•å‰10ä¸ªçš„è¯¦ç»†ä¿¡æ¯
                            console.log(`Token ${tokenId} çš„æ‰€æœ‰è€…:`, ownerResult);
                        }
                        
                        if (ownerResult && ownerResult !== '0x' && 
                            ownerResult !== '0x0000000000000000000000000000000000000000' &&
                            ownerResult === userAccount.toLowerCase()) {
                            // ç”¨æˆ·æ‹¥æœ‰è¿™ä¸ªNFTï¼Œå…ˆæ”¶é›†ä¿¡æ¯ï¼Œä¸ç«‹å³ç”Ÿæˆå¡ç‰‡
                            console.log(`âœ… æ‰¾åˆ°ç”¨æˆ·æ‹¥æœ‰çš„NFT: Token ${tokenId}`);
                            userNFTs.push(tokenId);
                            userNFTCount++;
                        }
                        
                        processedCount++;
                        
                        // æ¯å¤„ç†ä¸€æ‰¹ï¼Œæ›´æ–°çŠ¶æ€
                        if (processedCount % batchSize === 0) {
                            showStatus(`ğŸ” å·²æ£€æŸ¥ ${processedCount}/${maxSupply} ä¸ªTokenï¼Œæ‰¾åˆ° ${userNFTCount} ä¸ªNFT...`, 'info');
                            console.log(`å·²å¤„ç† ${processedCount}/${maxSupply} ä¸ªTokenï¼Œæ‰¾åˆ° ${userNFTCount} ä¸ªNFT`);
                            
                            // æ·»åŠ çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…è¯·æ±‚è¿‡äºé¢‘ç¹
                            await new Promise(resolve => setTimeout(resolve, 50));
                        }
                        
                    } catch (error) {
                        // tokenä¸å­˜åœ¨ï¼Œç»§ç»­ä¸‹ä¸€ä¸ª
                        if (processedCount < 10) { // åªè®°å½•å‰10ä¸ªé”™è¯¯
                            console.log(`Token ${tokenId} ä¸å­˜åœ¨æˆ–å‡ºé”™:`, error.message);
                        }
                        processedCount++;
                        continue;
                    }
                }
                
                console.log('=== æŸ¥æ‰¾å®Œæˆ ===');
                console.log('ç”¨æˆ·æ‹¥æœ‰NFTæ•°é‡:', userNFTCount);
                console.log('æ‰¾åˆ°çš„NFT Token IDs:', userNFTs);
                
                if (userNFTCount > 0) {
                    showStatus(`âœ… æ‰¾åˆ° ${userNFTCount} ä¸ªNFTï¼Œæ­£åœ¨åŠ è½½è¯¦ç»†ä¿¡æ¯...`, 'success');
                    
                    // æŒ‰å€’åºæ’åˆ—ï¼Œæœ€æ–°çš„æ’åœ¨å‰é¢
                    userNFTs.sort((a, b) => b - a);
                    console.log('å€’åºæ’åˆ—åçš„NFT Token IDs:', userNFTs);
                    
                    // åŠ è½½NFTè¯¦ç»†æ•°æ®
                    const nftDataList = [];
                    for (const tokenId of userNFTs) {
                        try {
                            const nftData = await loadNFTData(tokenId);
                            if (nftData) {
                                nftDataList.push(nftData);
                                console.log(`ğŸ“¦ å·²åŠ è½½NFT ${tokenId} è¯¦ç»†ä¿¡æ¯`);
                            }
                        } catch (nftError) {
                            console.error(`åŠ è½½NFT ${tokenId} æ•°æ®å¤±è´¥:`, nftError);
                        }
                    }
                    
                    showStatus(`âœ… æˆåŠŸåŠ è½½ ${nftDataList.length} ä¸ªNFTï¼`, 'success');
                    
                    // æ˜¾ç¤ºåœ¨ä¸¤ä¸ªæ ‡ç­¾é¡µ
                    const lotteryContainer = document.getElementById('lottery-nfts');
                    const ownedContainer = document.getElementById('owned-nfts-grid');
                    
                    // æ˜¾ç¤ºæœ€æ–°çš„5ä¸ªåœ¨æŠ½å¥–ç»“æœé¡µ
                    const recentNFTs = nftDataList.slice(0, 5);
                    displayNFTs(recentNFTs, lotteryContainer);
                    document.querySelector('#lottery-results .empty-state').style.display = 'none';
                    
                    // æ˜¾ç¤ºæ‰€æœ‰çš„åœ¨æ‹¥æœ‰é¡µé¢
                    displayNFTs(nftDataList, ownedContainer);
                    document.querySelector('#owned-nfts .empty-state').style.display = 'none';
                    
                    return nftDataList;
                    
                } else {
                    showStatus('ğŸ“­ æ‚¨è¿˜æ²¡æœ‰ä»»ä½•NFT', 'info');
                    console.log('ç”¨æˆ·æ²¡æœ‰æ‰¾åˆ°ä»»ä½•NFTï¼Œå¯èƒ½çš„åŸå› :');
                    console.log('1. ç”¨æˆ·ç¡®å®æ²¡æœ‰NFT');
                    console.log('2. ç½‘ç»œä¸åŒæ­¥');
                    console.log('3. åˆçº¦è°ƒç”¨æƒé™é—®é¢˜');
                    console.log('4. é’±åŒ…RPCèŠ‚ç‚¹é—®é¢˜');
                    return [];
                }
                
            } catch (error) {
                console.error('åŠ è½½ç”¨æˆ·NFTå¤±è´¥:', error);
                console.error('é”™è¯¯è¯¦æƒ…:', error.message, error.stack);
                showStatus('âš ï¸ åŠ è½½ç”¨æˆ·NFTå¤±è´¥: ' + error.message, 'error');
                return [];
            }
        }

        // è°ƒè¯•NFTåŠ è½½åŠŸèƒ½
        async function debugNFTLoading() {
            if (!walletProvider || !userAccount) {
                showStatus('âŒ è¯·å…ˆè¿æ¥é’±åŒ…', 'error');
                return;
            }

            console.log('ğŸ› å¼€å§‹è°ƒè¯•NFTåŠ è½½...');
            showStatus('ğŸ› å¼€å§‹è°ƒè¯•NFTåŠ è½½ï¼Œè¯·æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°', 'info');
            
            try {
                // ä½¿ç”¨å®Œæ•´çš„NFTåŠ è½½å‡½æ•°è¿›è¡Œè°ƒè¯•
                const nfts = await loadUserNFTsComplete();
                
                if (nfts.length > 0) {
                    console.log('âœ… è°ƒè¯•æˆåŠŸï¼æ‰¾åˆ°NFT:', nfts.length);
                    showStatus(`âœ… è°ƒè¯•æˆåŠŸï¼æ‰¾åˆ°å¹¶æ˜¾ç¤ºäº† ${nfts.length} ä¸ªNFT`, 'success');
                } else {
                    console.log('âŒ è°ƒè¯•å®Œæˆï¼Œä½†æ²¡æœ‰æ‰¾åˆ°ä»»ä½•NFT');
                    showStatus('âŒ è°ƒè¯•å®Œæˆï¼Œä½†æ²¡æœ‰æ‰¾åˆ°ä»»ä½•NFT', 'error');
                }
                
            } catch (error) {
                console.error('âŒ è°ƒè¯•è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
                showStatus(`âŒ è°ƒè¯•å¤±è´¥: ${error.message}`, 'error');
            }
        }
    </script>
</body>
</html>